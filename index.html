<!DOCTYPE html>
<html lang="en" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My CV - Santiago Aguilera</title>
    <!-- <link rel="stylesheet" href="styles/_main.css"> -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.14.1/dist/cdn.min.js"></script>
    <script src="https://kit.fontawesome.com/5d0685a413.js" crossorigin="anonymous"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',

            variants: {
                extend: {
                    scrollbar: ['rounded'],
                    },
            },
            plugins: [
                function({ addUtilities }) {
                    addUtilities({
                        '.scrollbar-hide': {
                        /* Hide scrollbar for Chrome, Safari and Opera */
                        '&::-webkit-scrollbar': {
                            display: 'none'
                        },
                        /* Hide scrollbar for IE, Edge and Firefox */
                        '-ms-overflow-style': 'none',
                        'scrollbar-width': 'none'
                        },
                        '.scrollbar-thin': {
                        '&::-webkit-scrollbar': {
                            width: '8px',
                            height: '8px'
                        }
                        },
                        '.scrollbar-thumb-rounded': {
                        '&::-webkit-scrollbar-thumb': {
                            borderRadius: '8px'
                        }
                        },
                        '.scrollbar-thumb': {
                        '&::-webkit-scrollbar-thumb': {
                            backgroundColor: '#4A5568'
                        }
                        },
                        '.scrollbar-track': {
                        '&::-webkit-scrollbar-track': {
                            backgroundColor: 'rgba(31, 41, 55, 0.6)'
                        }
                        },
                    })
                }
            ]
        }
    </script>

</head>
<body x-cloak class="text-base md:text-lg">
<div 
    x-cloak
    x-show="visible"
    x-data="{
        url: '', 
        visible: false, 
        isVideo(url) { return url.match(/\.(mp4|webm|ogg)$/i); },
        isPdf(url) { return url.match(/\.pdf$/i); }
    }"
    @notify.window="url = $event.detail; visible = true"
    class="p-4 w-full bg-black/80 flex items-center justify-center z-20 fixed inset-0 overflow-y-auto"
>
    <div class="relative group" @click.outside="visible = false">

        <!-- Video -->
        <template x-if="isVideo(url)">
            <video 
                x-bind:src="url" 
                class="w-full max-h-[480px] rounded-md max-w-screen-lg" 
                controls autoplay muted loop>
            </video>
        </template>

        <!-- PDF -->
        <template x-if="isPdf(url)">
            <!-- <embed x-bind:src="url" type="application/pdf" width="100%" height="600px" /> -->
            <!-- <iframe x-bind:src="url" width="1080px" height="720px"> -->
            <iframe 
            x-bind:src="url" 
            class="
                w-[320px] h-[480px]       <!-- default: small phones -->
                sm:w-[480px] sm:h-[640px] <!-- larger phones / small tablets -->
                md:w-[768px] md:h-[576px] <!-- tablets -->
                lg:w-[1024px] lg:h-[640px] <!-- laptops -->
                xl:w-[1280px] xl:h-[720px] <!-- desktops -->
                2xl:w-[1536px] 2xl:h-[864px] <!-- big monitors -->
            ">
            This browser does not support PDFs. Please download the PDF to view it: 
            <a x-bind:href="url">Download PDF</a>.
            </iframe>

        </template>

        <!-- Image -->
        <template x-if="!isVideo(url) && !isPdf(url)">
            <img 
                x-bind:src="url" 
                class="w-full max-h-[480px] rounded-md max-w-screen-lg" 
                alt="">
        </template>
    </div>
</div>


<div x-data="custom" class="h-screen flex flex-col items-center justify-center p-4 bg-center bg-cover bg-[url('images/02.jpg')]">

    <div cv-scrollbar
    class="max-w-screen-lg w-full pt-4 shadow-lg text-gray-100 font-mono subpixel-antialiased bg-gray-800/60 rounded-lg leading-normal">
        <div class="mb-4 px-5 flex">
            <div class="h-3 w-3 bg-red-500 rounded-full"></div>
            <div class="ml-2 h-3 w-3 bg-orange-300 rounded-full"></div>
            <div class="ml-2 h-3 w-3 bg-green-500 rounded-full"></div>
        </div>

        <div x-ref="container"
        class="px-5 pb-6 overflow-y-auto w-full max-h-[468px] sm:max-h-[568px] scrollbar-thin scrollbar-thumb scrollbar-thumb-rounded scrollbar-track">

        </div>
    </div>
    
  </div>
    <!-- <script type="module"></script> -->
     <!-- <script src="cv-laravel.js"></script> -->
    <script>
        // console.log(cv);
        function logKeyEvent(event) {
            console.log(`Key event: ${event.type}, Key: ${event.key}`);
        }

        document.addEventListener('alpine:init', ()=> {

            
            Alpine.data('custom', () => ({
                cursor: "after:content-['\\2588'] after:animate-ping",
                shell_speed: 300,
                text_speed: 50,
                fileName: 'cv-laravel',
                autoScroll: true,
                programmaticScroll: false,
                lastScroll: 0,
                spinning: false,
                whiteList: [],

                init() {

                    const OFFSET = 5;

                    this.$refs.container.addEventListener('scroll', (event) => {
                        const currentScroll = event.target.scrollTop;

                        if (this.autoScroll && currentScroll < this.lastScroll - OFFSET) {
                            this.autoScroll = false;

                            // Optional: restore autoscroll after 5s
                            setTimeout(() => {
                                this.autoScroll = true;
                                this.spinning = false;
                            }, this.spinning ? 
                            0 : 5000);
                        }

                        this.lastScroll = currentScroll;
                    });

                    const searchParams = new URLSearchParams(window.location.search);

                    const params = Object.fromEntries(searchParams.entries());
                    var lang;

                    if(params.lang == undefined || !['es', 'en'].includes(params.lang)) {
                        lang = this.getDefaultLang();
                    } else {
                        lang = params.lang;
                    }

                    if(params.cv == undefined) {
                        this.fileName = 'cv';
                    } else {
                        this.fileName = params.cv;
                    }

                    if(params.just != undefined) {
                        const sections = params.just.split(",").map(s => s.trim());
                        this.whiteList = sections;
                    }

                    // var lang = this.askLanguage();
                    this.createAndAppendScript(`${this.fileName}-${lang}.js`, 
                    () => {
                        if(this.whiteList.length > 0) {
                            this.cvWithJustListedSections(cv);
                        }

                        this.execCommand(cv.resume[0], 0)
                    }, (src) => {
                        console.log(new Error(`Failed to load cv: ${src}, loading easter egg cv`))
                        this.fileName = `easter-egg-${lang}.js`;
                        this.createAndAppendScript(this.fileName, () => {
                            this.execCommand(cv.resume[0], 0)
                        }, () => { 
                            console.log(new Error(`Failed to load easter egg`))
                        });
                    });

                },

                cvWithJustListedSections(cv) {
                    const sections = [];

                    for(section of cv.resume) {
                        for(item of this.whiteList) {
                            if(section.command.includes(item)) {
                                sections.push(section);
                            }
                        }
                    }

                    cv.resume = sections;
                },

                createAndAppendScript(src, startCV, onError) {
                    const script = document.createElement('script');
                    script.src = src;
                    document.head.appendChild(script);

                    script.onload = () => startCV(); // Waits until script is fully loaded
                    script.onerror = () => onError(src);
                },

                getDefaultLang() {
                    return navigator.language.startsWith('es') ? 'es' : 'en';
                },

                askLanguage() {
                    if (navigator.language.startsWith('es')) {
                        const es = confirm(
                            `Idioma detectado: Español.\n\nPresiona 'Aceptar' para confirmar.\n\nPresiona 'Cancelar' para usar Inglés.`
                        );
                        return es ? 'es' : 'en';
                    } else {
                        const en = confirm(
                            `Detected language: English.\n\nPress 'OK' to confirm.\n\nPress 'Cancel' to use Spanish.`
                        );
                        return en ? 'en' : 'es';
                    }
                },

                execCommand(command, index)
                {
                    if(index < cv.resume.length)
                    {
                        let step = 0;
                        this.buildElement(command.output, step, () => {
                            setTimeout(() => {
                                // console.log("h");
                                index++;
                                this.execCommand(cv.resume[index], index);
                            }, this.shell_speed);
                        });
                    }
                },

                component: false,
                nestable: false,
                elInserted: false,

                buildElement(schema, step, nextCommand, stack = []) 
                {
                    if(this.autoScroll) {
                        this.$refs.container.scrollTop = this.$refs.container.scrollHeight;
                    }
                    
                    if(step < schema.length) 
                    {
                        
                        
                        let str = schema[step];
                        if(str.startsWith('HTML'))
                        {
                            [html, tag, classes, attrs] = str.split("|");
                            let unnest = html.split("%")[1]?.split("-")[0] == 'break';
                            let times = html.split("%")[1]?.split("-")[1] ?? 1;
                            while(unnest && times--) stack.pop();
                            let el = document.createElement(tag);
                            this.nestable = html.split("%")[1] == 'nestable';
                            this.addClassesAndAttrs(el, classes, attrs);

                            let wrapper = stack[this.peekOf(stack)]


                            if(wrapper) 
                            {
                                stack[this.peekOf(stack)].append(el); 
                            }

                            stack.push(el);

                            if(!this.elInserted) {
                                this.$refs.container.append(stack[0])      
                            }else this.elInserted = true;

                            setTimeout(() => {
                                this.buildElement(schema, ++step, nextCommand, stack);
                            }, 300)
                            return;
                        }

                        if(str.startsWith("COMPONENT"))
                        {
                            let [component, name, classes, attrs, content] = str.split("|");
                            console.log(classes, attrs);
                            let unnest = component.split("%")[1] == 'break';
                            if(unnest) stack.pop();
                            const rootable = component.split("%")[1] == 'break';
                            const cv_schema = Array.from(cv.components[name].schema);
                            setTimeout(() => {
                                this.component = true;
                                this.buildElement(cv_schema, 0, (_stack) => {
                                    let el = _stack.pop();
                                    console.log(el, classes, attrs);
                                    this.addClassesAndAttrs(el, classes, attrs);
                                    if(!content) {
                                        setTimeout(() => {
                                            if(name == 'spin') {
                                                _stack[0].remove();
                                                this.spinning = true;
                                            }
                
                                            this.buildElement(schema, ++step, nextCommand, stack)
                                        }, 200)
                                    }
                                    else
                                        setTimeout(() => {
                                            this.addClasses(this.cursor, el);
                                            this.applyTransition(el, content, 0, () => {
                                                this.removeClasses(this.cursor, el)
                                                this.buildElement(schema, ++step, nextCommand, stack)
                                            });
                                        }, 200)
                                })
                            }, 100);

                            return;
                        }
                        
                        let el;
                        if(this.nestable) {
                            this.nestable = false;
                            el = stack[this.peekOf(stack)];
                        }
                        else{
                            el = stack.pop();
                        }

                        if(this.component) {
                            this.component = false;

                            el.append(str);

                            setTimeout(() => {
                                this.buildElement(schema, ++step, nextCommand, stack)
                            }, 200);
                            return;
                        }

                        let [text, waitable] = str.split("|");
                        let times = waitable ? this.getRandom() : 0;
                        
                        setTimeout((self) => {
                            this.addClasses(this.cursor, el);
                            self.applyTransition(el, text, 0, function applyWait() {
                                self.removeClasses(self.cursor, el);
                                if(times > 0) 
                                { 
                            
                                    let pattern = [".·.·", "·.·.", ".·.·", "·.·."][times]
                                    times--;
                                    setTimeout(() => {
                                        self.applyTransition(el, '...', 0, () => {
                                            el.innerHTML = text;
                                            applyWait();
                                        }, 150);
                                    }, 100);
                                }
                                else
                                {
                                    if(waitable)
                                        el.innerHTML += "... <span class=\"text-green-400 ml-4\">Done</span>"
                                    self.buildElement(schema, ++step, nextCommand, stack)
                                }
                            });
                        }, 200, this)
                    }
                    else {
                        nextCommand(stack);
                    }                        
                },

                applyTransition(el, text, char, next, textSpeed = this.text_speed) 
                {
                    if(char < text.length)
                    {
                        el.insertAdjacentHTML('beforeend', text.charAt(char));
                        if(this.autoScroll) {
                            this.$refs.container.scrollTop = this.$refs.container.scrollHeight
                        }
                        // el.append(node);
                        setTimeout(() => this.applyTransition(el, text, ++char, next), textSpeed);   
                    }
                    else {
                        next();
                    }
                },
            
                addClassesAndAttrs(el, classes, attrs, separator = " ") {
                    this.addClasses(classes, el);
                    this.mappedAttrs(attrs).forEach(tuple => {
                        [attr, value] = tuple;
                        
                        if(attr && !el.hasAttribute(attr))
                            el.setAttribute(attr, value);

                    });
                    return el;
                },

                getRandom(min = 1, max = 4) 
                {
                    return Math.random() * (max - min) + min;
                },


                addClasses(strClass, el) {
                    if(!strClass) return;
                    const classes = strClass?.split(" ") ?? [];
                    classes.forEach(cls => el.classList.add(cls));
                },

                removeClasses(strClass, el)
                {
                    if(!strClass) return;

                    const classes = strClass.split(" ");
                    classes.forEach(cls => el.classList.remove(cls));
                },

                peekOf: (stack) => stack.length - 1,

                mappedAttrs(attrs, separator = " ") {
                return attrs?.split(separator)
                    ?.map(tuple => {
                    let i = tuple.indexOf("=");
                    if (i === -1) return [tuple, true]; // flag for boolean attrs
                    return [tuple.slice(0, i), tuple.slice(i + 1)];
                    }) ?? []; 
                }

            }))
        })
    </script>
</body>
</html>